:experimental:
:icons: font
:source-highlighter: pygments
:pygments-style: manni
:pygments-linenums-mode: inline
:last-update-label!:

= Boteco

What if you could write a bot that works on every chat platform? Boteco is a set of abstractions that allows you to write a bot that have the same behaviour across different platforms.

Boteco is gladly built on top of JBoss Fuse.

== How to build

=== Pre Requisites

Make sure you have https://maven.apache.org[Apache Maven] installed and a profile in your `settings.xml` file to fetch
JBoss Fuse artifacts.

[source,xml]
----
<profile>
  <id>fusesource</id>
  <activation>
    <activeByDefault>true</activeByDefault>
  </activation>
  <repositories>
    <repository>
      <id>fuse-public-repository</id>
      <name>FuseSource Community Release Repository</name>
      <url>https://repo.fusesource.com/nexus/content/groups/public</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <enabled>true</enabled>
      </releases>
    </repository>
    <repository>
      <id>fusesource.ea</id>
      <name>JBoss Community Early Access Release Repository</name>
      <url>https://repo.fusesource.com/nexus/content/groups/ea</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <enabled>true</enabled>
      </releases>
    </repository>
  </repositories>
  <pluginRepositories>
    <pluginRepository>
      <id>fuse-public-repository</id>
      <name>FuseSource Community Release Repository</name>
      <url>https://repo.fusesource.com/nexus/content/groups/public</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <enabled>true</enabled>
      </releases>
    </pluginRepository>
    <pluginRepository>
      <id>fusesource.ea</id>
      <name>JBoss Community Early Access Release Repository</name>
      <url>https://repo.fusesource.com/nexus/content/groups/ea</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <enabled>true</enabled>
      </releases>
    </pluginRepository>
  </pluginRepositories>
</profile>
----

=== Build Step

Just do the classical Maven command:

[source,bash]
----
$ mvn install
----

== How to run

It's easier than fall of a bike! From your Fuse console, do the following commands:

[source]
----
features:addurl mvn:tools.devnull/boteco-features/1.0.0/xml/features #<1>

features:install boteco #<2>
----
<1> Use the version you desire to run
<2> Installs all necessary bundles to run Boteco (base, plugins and channels)

[NOTE]
====
Built in channels will start automatically but you need to configure them correctly.

See the channel projects for details about how to configure each one.
====

If you want to specify which channels you want, you can use the other features:
[source]
----
features:addurl mvn:tools.devnull/boteco-features/1.0.0/xml/features

features:install boteco-base
features:install boteco-plugins
features:install boteco-channels

osgi:start boteco-channel-telegram boteco-channel-pushover boteco-channel-irc
----

== Concepts

Boteco consists basically on the following components:

- *Channel*: a channel is responsible for doing the communication between the Bot and the chat platform.
- *IncomeMessage*: represents a content received from a channel.
- *MessageProcessor*: process income messages.

The flow is pretty simple: a content arrives through a channel, is passed to a processor and the response is send back through the same channel. The figure bellow illustrates the flow:

image::./assets/overview.png[Overview]

But how messages from different channels can be processed by the same processor? Let's find out!

=== Message Processor

A Message Processor is a class that implements the _MessageProcessor_ interface:

[source,java]
----
public class PingMessageProcessor implements MessageProcessor {

  @Override
  public boolean canProcess(IncomeMessage message) { //<1>
    return check(message).accept(command("ping")); //<2>
  }

  @Override
  public void process(IncomeMessage message) { //<3>
    message.reply("%s: pong", message.sender()); //<4>
  }

}
----
<1> Checks if the processor can process a message
<2> Built in DSL to help you write the check code
<3> Process the given message
<4> Reply to the message without worrying how to send it

=== Channel

Your Message Processor doesn't need to know how to send a content, but the Channel needs. A Channel is the integration between the chat platform and the Boteco runtime, a *camel route* is the most obvious thought.

A Channel needs to receive a content, wraps it in an instance of `IncomeMessage` and then send to the `MessageProcessor`.

[NOTE]
====
Boteco comes with some channel implementations. Look for the `channels` folder to see how they are implemented and how you can configure them.
====

=== Routing to Message Processor

When you write a channel, you need to pass the income content to be processed (or not). Instead of writing the code to find the Message Processor, you can use a MessageDispatcher to do the work. Boteco comes with a OSGi bundle that uses the OSGi Registry to discover the Message Processors, allowing you to _hot-deploy_ a Message Processor.

To send an income message for processing you just need a reference to a `tools.devnull.boteco.message.MessageDispatcher` service. The default implementation (in `boteco-message-processor` module) sends the message to a processing queue.
